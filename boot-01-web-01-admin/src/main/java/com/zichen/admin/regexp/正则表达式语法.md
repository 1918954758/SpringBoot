# 正则表达式语法

## 1. 转义符  \\ 
- . * + ( ) $ / \ ? [ ] ^ { }
- 对于减号（-）：转义不转义都可以，都可以匹配成功

## 2. 字符匹配符
- []        可接受的字符序列        [efdgda]        匹配中括号里面任意一个
- [^]       不接受的字符序列        [^fasdf]        匹配中括号汇总以外任意一个字符
- -         连字符                 A-Z             匹配A到Z之间任意一个字符
- .         匹配除\n以外的任意字符    a..b            a开头b结尾，中间包括2个任意字符的长度为4的字符串    a34b   aerb  a()b  ...
- \\d       匹配单个数字字符 相当于 [0-9]
- \\D       匹配单个非数字字符 相当于 [^0-9]
- \\w       匹配单个数字、字母、下横线 相当于 [a-zA-Z0-9_]
- \\W       匹配单个非数字、非字母、非下横线 相当于 [^a-zA-Z0-9_]
- \\s       匹配空白符、制表符等（比如，空格，tab、制表、回车等）
- \\S       匹配非空白符、非制表符等

### 2.1. 对大小写不明感 (?i)
- 如果想让那个字符不区分大小写
```java
class IgnoreLowerOrUpper {
    public static void main(String[] args) {
        String content = "abcaBcEGBfda";
        // b不区分大小写
        String regex = "a((?i)b)c";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```
- 如果想让最后多个字符不区分大小写
```java
class IgnoreLowerOrUpper {
    public static void main(String[] args) {
        String content = "abcaBcEGBfdaBCGEdfeABC";
        // bc不区分大小写
        String regex = "a(?i)bc";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```
- 如果想让整句话都不区分大小写

```java
class IgnoreLowerOrUpper {
    public static void main(String[] args) {
        String content = "abcaBcEGBfda";
        String regex = "abc";
        //整句不区分大小写
        Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group(0));
        }
    }
}
```

## 3， 选择匹配符
- |     匹配 | 之前或者之后的表达式  and的关系

## 4. 限定符
- *         匹配 >= 0 个
- +         匹配 >= 1 个
- ?         匹配 = 0 | = 1 个
- {n}       匹配  = n 个 （包括n）
- {n, m}    匹配 n到m之间 个 （包括n,m）（尽可能多的匹配，也就是说能匹配5个绝不匹配3个）
- {m,}      匹配 >= n 个 （包括n）（尽可能多的匹配，也就是说能匹配5个绝不匹配3个）
- {,m}      匹配 <= m 个 （包括m）（尽可能多的匹配，也就是说能匹配5个绝不匹配3个）

- ?         如果跟在限定符后面，那么就变成了了非贪婪匹配（java中限定符匹配都是贪婪匹配）
```java
/**
 * @name: RegExp_06
 * @description: 贪婪匹配 和 非贪婪匹配
 * @author: zichen
 * @date: 2021/6/5  13:06
 */
public class RegExp_06 {
    public static void main(String[] args) {
        String content = "11133344566534543";
        //String regex = ".+";//贪婪匹配   匹配到： 11133344566534543
        String regex = ".+?";//非贪婪匹配   匹配到： 1
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        boolean b = matcher.find();
        System.out.println("" + (b == true ? matcher.group() : -1));
    }
}
```

- ? 和 . 写在中括号里面就是实实在在的问号，而不表示限定符
  - '(\\.\\?)([.?])'
```java
/**
 * @name: RegExp_07
 * @description:  .   and   ?  中括号里面的点和问号，可以不用转义，其他位置的点或者问号需要转义
 * @author: zichen
 * @date: 2021/6/5  13:44
 */
public class RegExp_07 {
    public static void main(String[] args) {
        String content = "11133.344566.?534543";
        //String regex = "(.)";// 1
        //String regex = "(.)"; // 1
        //String regex = "[.]";//  .
        String regex = "[\\.]";// .
        //String regex = "(?)";//
        //String regex = "(\\?)"; // ?
        //String regex = "[?]";// ?
        //String regex = "[\\?]"; // ?
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        boolean b = matcher.find();
        System.out.println("" + (b == true ? matcher.group() : -1));
    }
}
```

## 5. 定位符
- ^     字符串开始位置
- $     字符串结束位置
- \\b   匹配目标字符串的边界（开始位置或者结束位置） （Linux中也可使用 \< - 开始位置  \> - 结束位置）
- \\B   匹配目标字符串的非边界（目标字符串的非开始位置或者非结束位置）

## 6. 分组
- (pattern)
    - 非命名捕获。捕获匹配的子字符串。
    - 编号为0的第一个捕获是由整个正则表达式匹配的文本，
    - 其他捕获结果则根据左括号的顺序从1开始自动编号。
- (?<name>pattern)
    - 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。
    - 用于name的字符串不能包含任何标点符号，并且不能以数字开头。
    - 可以使用单引号替代尖括号，例如(?'name')
```java
/**
 * @name: RegExp_02
 * @description: 分组 (?<name>pattern)   (?'name'pattern)
 * @author: zichen
 * @date: 2021/6/5  12:31
 */
public class RegExp_02 {
    public static void main(String[] args) {
        String content = "abcdefA BCe t35$13g adf#43qg";
        String regex = "(?<g1>abc)(?<g2>def)";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到所有: " + matcher.group(0));
            System.out.println("找到第1组: " + matcher.group(1));
            System.out.println("找到第1组【命名捕获】: " + matcher.group("g1"));
            System.out.println("找到第2组: " + matcher.group(2));
            System.out.println("找到第2组【命名捕获】: " + matcher.group("g2"));
        }
    }
}
/**
 * 找到所有: abcdef
 * 找到第1组: abc
 * 找到第1组【命名捕获】: abc
 * 找到第2组: def
 * 找到第2组【命名捕获】: def
 */
```

- (?:pattern)
    - 不可以被捕获，也就是说不可以使用group(1)这样子来获取匹配到的内容
    - 'industr(?:y|ies)' 这样可以匹配到 industry 或者匹配到 industries两个内容
    - 等价于 'industry|industries'
```java
/**
 * @name: RegExp_03
 * @description: 分组：(?:pattern)  等价于 'mmma|mmmb' mmm(?:a|b)
 * @author: zichen
 * @date: 2021/6/5  12:37
 */
public class RegExp_03 {
    public static void main(String[] args) {
        String content = "industry_345_industriesy5heg";
        String regex = "industr(?:y|ies)";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到： " + matcher.group());
        }
    }
}
/**
 * 找到： industry
 * 找到： industries
 */
```

- (?=pattern)
  - 不可以被捕获，也就是不可以使用group(1),group(2)这样来获取匹配到的内容
  - 'Windows(?=85|98|NT|2000)'  匹配括号前的内容，即 Windows
  - 它可以找到 Windows85中的Windows   Windows98中的Windows   WindowsNT中的Windows  以及 Windows2000中的Windows，这四个内容中的Windows
  - 但是不可以找到 Windows3.1中的Windows 这样的内容
  - 也就是，不可以找到括号里面的那四个限定内容之外的内容
```java
/**
 * @name: RegExp_04
 * @description: 分组： (?=a|b|c)  mmma中的mmm或者mmmb中的mmm或者mmmc中的mmm   找不到 mmmd中的mmm。。。
 * @author: zichen
 * @date: 2021/6/5  12:46
 */
public class RegExp_04 {
    public static void main(String[] args) {
        String content = "可以找到 Windows85中的Windows   Windows98中的Windows % Windows3.1  WindowsNT中的Windows  以及 Windows2000中的Windows，这四个";
        String regex = "Windows(?=85|98|NT|2000)";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到： " + matcher.group());
        }
    }
}
/**
 * 找到： Windows
 * 找到： Windows
 * 找到： Windows
 * 找到： Windows
 */
```

- (?!pattern)
  - 不可以被捕获，也就是不可以使用group(1),group(2)这样来获取匹配到的内容
  - 'Windows(?=85|98|NT|2000)'  匹配括号前的内容，即 Windows
  - 它可以找到 除了 Windows85中的Windows   Windows98中的Windows   WindowsNT中的Windows  以及 Windows2000中的Windows，这四个内容之外的Windows
  - 但是可以找到 Windows3.1中的Windows等等
  - 也就是，可以找到括号里面的那四个限定内容之外的内容
```java
/**
 * @name: RegExp_05
 * @description: 分组： (?!pattern)  mmm(?!a|b|c) 找不到mmma中的mmm  找不到mmmb中的mmm   找不到mmmc中的mmm
 * @author: zichen
 * @date: 2021/6/5  12:54
 */
public class RegExp_05 {
    public static void main(String[] args) {
        String content = "可以找到 Windows85中的Windows   Windows98中的Windows % Windows3.1  WindowsNT中的Windows  以及 Windows2000中的Windows，这四个";
        String regex = "Windows(?!85|98|NT|2000)";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到： " + matcher.group());
        }
    }
}
/**
 * 找到： Windows
 * 找到： Windows
 * 找到： Windows
 * 找到： Windows
 * 找到： Windows
 */
```

## 7. 应用实例
- 验证汉字
  - '^[\u0391-\uffe5]$'
- 验证邮编 1-9开头 的 6位数
  - '^[1-9]\\d{5}$'
- 验证QQ号码 1-9开头的一个（5-11位数）
  - '^[1-9]\\d{4,10}$'
- 验证手机号  必须以13,14,15,18 开头的11位数
  - '^1[3|4|5|8]\\d{9}$'

## 8. Pattern类
- boolean isSuccess = pattern.matches(regex, content);
  - 整体匹配成功返回true
  - 整体匹配失败返回false
  
## 9. 反向引用
- 分组：
    - 我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看做是一个子表达式/一个分组
- 捕获：
    - 把正则表达式中子表达式/分组匹配的内容，保存到内存中，以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则表达式
- 反向引用：
  - 圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称之为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部
  - 内部反向引用
    - \\分组号
  - 外部反向引用
    - $分组号
- 反向引用实例（正则表达式内部）：
  - 1. 要匹配两个连续的相同数字
    - (\\d)\\1    \\d 匹配数字  \\1 反向引用第一组的内容  一共两个数字
  - 2. 要匹配五个连续的相同数字
    - (\\d)\\1{4}    \\d 匹配数字  \\1 反向引用第一组的内容  {4}匹配4次   一共五个数字
  - 3. 要匹配个位与千位相同，十位与百位相同的数，如5225，9889...
    - (\\d)(\\d)\\2\\1
```java
/**
 * @name: RegExp_08
 * @description:反向引用
 * @author: zichen
 * @date: 2021/6/5  14:44
 */
public class RegExp_08 {
    public static void main(String[] args) {
        String content = "12534321-33311155574333-33344466699913515411";
        String regex = "\\d{5}-(\\d)\\1{2}(\\d)\\2{2}(\\d)\\3{2}";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到：" + matcher.group());
        }
    }
}
/**
 * 找到：34321-333111555
 * 找到：74333-333444666
 */
```

- 反向引用实例（正则表达式外部）：
```java
/**
 * @name: RegExp_09
 * @description:反向引用实例（正则表达式外部）
 * @author: zichen
 * @date: 2021/6/5  14:54
 */
public class RegExp_09 {
    public static void main(String[] args) {
        String newStr = "abc def".replaceFirst("(\\w+)\\s+(\\w+)", "$2 $1");
        System.out.println(newStr);
    }
}
/**
 * def abc
 */
```
```java
/**
 * @name: RegExp_10
 * @description:结巴程序
 * @author: zichen
 * @date: 2021/6/5  15:02
 */
public class RegExp_10 {
  public static void main(String[] args) {
    String content ="1..22...333....4444.....55555......666666.......7777777.....8888888.....";

    String s1 = content.replaceAll("(\\d*)(\\.*)", "$1$2");
    String s2 = content.replaceAll("(\\d)*(\\.)*", "$1$2");
    String s3 = content.replaceAll("(.)\\1+", "$1");
    System.out.println(s1);
    //1..22...333....4444.....55555......666666.......7777777.....8888888.....
    System.out.println(s2);
    //1.2.3.4.5.6.7.8.
    System.out.println(s3);
    //1.2.3.4.5.6.7.8.

    String s = Pattern.compile("(.)\\1+").matcher(content).replaceAll("$1");
    System.out.println(s);
    //1.2.3.4.5.6.7.8.
  }
}
```

## 10. 字符串中的验证、替换和分割
- 验证
  - boolean isSuccess = "13853265743".matches("^13[2|8|9]\\d{8}");
- 替换
  - "124-34-54~6543~534-453".replaceAll("-|~", "-");
- 分割
  - String[] str = "124-34-54~6543~534-453".split("-|~");

- 验证实例：
```java
/**
 * @name: RegExp_11
 * @description: 验证整数或者小数，要求考虑正负号  不匹配 00.343
 * @author: zichen
 * @date: 2021/6/5  15:59
 */
public class RegExp_11 {
  public static void main(String[] args) {
    //String content = "-1 2.453 14.65 0.34 3@54";
    Scanner scanner = new Scanner(System.in);
    System.out.println("请输入一个数（正数、负数、小数、整数...）");
    String content = scanner.nextLine();
    //String regex = "^[-]?(([0])|([^0][0-9]+))(\\.\\d+)?$"; 
    String regex = "^[-]?([1-9]\\d*|0)+(\\.\\d+)?$";
    Matcher matcher = Pattern.compile(regex).matcher(content);
    if (matcher.find()) {
      System.out.println("匹配成功！");
      System.out.println(matcher.group());
    } else  {
      System.out.println("匹配失败！");
    }
  }
}
```

## 11. 分组实例
```java
/**
 * @name: RegExp_12
 * @description: 分组实例
 * @author: zichen
 * @date: 2021/6/5  16:24
 */
public class RegExp_12 {
    public static void main(String[] args) {
//        String content = "http://www.sohu.com:8080/abc/index.htm";
//        String regex = "^([a-zA-Z]+)://([\\w-.]+):(\\d+)[\\w-/]*/([\\w.]+)$";
//        Matcher matcher = Pattern.compile(regex).matcher(content);
//        while (matcher.find()) {
//            System.out.println("ALL：" + matcher.group(0));
//            System.out.println("协议：" + matcher.group(1));
//            System.out.println("域名：" + matcher.group(2));
//            System.out.println("端口号：" + matcher.group(3));
//            System.out.println("资源：" + matcher.group(4));
//        }

        //命名捕获
        String content = "http://www.sohu.com:8080/abc/index.htm";
        String regex = "^(?<protocol>[a-zA-Z]+):\\/\\/(?<dumainname>[\\w-.]+):(?<port>\\d+)[\\w-/]*\\/(?<pageuri>[\\w.]+)$";
        Matcher matcher = Pattern.compile(regex).matcher(content);
        while (matcher.find()) {
            System.out.println("ALL：" + matcher.group(0));
            System.out.println("协议：" + matcher.group("protocol"));
            System.out.println("域名：" + matcher.group("dumainname"));
            System.out.println("端口号：" + matcher.group("port"));
            System.out.println("资源：" + matcher.group("pageuri"));
        }
    }
}
/**
 * ALL：http://www.sohu.com:8080/abc/index.htm
 * 协议：http
 * 域名：www.sohu.com
 * 端口号：8080
 * 资源：index.htm
 */
```