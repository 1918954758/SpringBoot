## 拦截器

### 1. 编写一个拦截器，实现HanderInterceptor接口

```java
/**
 * @name: LoginInterceptor
 * @description:
 * @author: zichen
 * @date: 2021/5/15  15:14
 */
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 拦截执行目标方法前置处理
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        String requestURI = request.getRequestURI();
        log.info("拦截器的请求路径是{}", requestURI);

        // 登录检查逻辑
        HttpSession session = request.getSession();

        Object loginUser = session.getAttribute("loginUser");

        if (loginUser != null) {
            // session中用户不为空，则放行
            return true;
        }

        // 拦截
        // 使用session，必须是登录之后才能拿到信息
        //session.setAttribute("msg", "请先登录！");
        //response.sendRedirect("/");
        // 使用request域，不需要登录之后就可以拿到消息
        request.setAttribute("msg", "请先登录！");
        request.getRequestDispatcher("/").forward(request, response);
        return false;
    }

    /**
     * 拦截目标方法执行之后
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    }

    /**
     *
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    }
}
```
### 2. 配置拦截器(将编写的拦截器，注册到容器中)

```java
/**
 * @name: AdminWebConfig
 * @description:
 * @author: zichen
 * @date: 2021/5/15  15:22
 */
@Configuration
public class AdminWebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                // 放行所有请求
                .addPathPatterns("/**")
                // 不拦截静态资源，以及登录页
                .excludePathPatterns("/", "/login", "/css/**", "/fonts/**", "/images/**", "/js/**");
    }
}
```
### 3. 验证拦截器

- 拦截的请求，跳转到登录页
- 登录页提示“还未登录”
- 这里使用 请求域存放提示信息比较合适
    - 因为请求域的信息不需要登录就可以获取到，而session不登录是获取不到信息的

```java
// 拦截
// 使用session，必须是登录之后才能拿到信息
//session.setAttribute("msg", "请先登录！");
//response.sendRedirect("/");
// 使用request域，不需要登录之后就可以拿到消息
request.setAttribute("msg", "请先登录！");
request.getRequestDispatcher("/").forward(request, response);
```

![image-拦截效果](../image/拦截效果.png)

- 拦截器执行过程
    - preHandle
    - postHandle
    - afterCompletion

![image-拦截器执行流程](../image/拦截器执行流程.png)